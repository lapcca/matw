# MATW Phase 4-6 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:subagent-driven-development to implement this plan task-by-task.

**Goal:** Build TUI interface, MCP plugin system, and full agent orchestration for MATW

**Architecture:**
- Phase 4: ratatui TUI with terminal UI
- Phase 5: MCP (Model Context Protocol) plugin system
- Phase 6: Agent orchestration with tool execution

**Tech Stack:** ratatui 0.28, crossterm, tokio sync, JSON-RPC 2.0

---

## Phase 4: TUI with ratatui

### Task 18: Create matw-tui Crate

**Files:**
- Create: `crates/matw-tui/Cargo.toml`
- Create: `crates/matw-tui/src/lib.rs`

**Step 1: Update workspace**

```toml
[workspace]
members = [
    "crates/matw-core",
    "crates/matw-ai",
    "crates/matw-tools",
    "crates/matw-tui",
]
```

**Step 2: Create Cargo.toml**

```toml
[package]
name = "matw-tui"
version = "0.1.0"
edition = "2021"

[dependencies]
matw-core = { path = "../matw-core" }
matw-ai = { path = "../matw-ai" }
matw-tools = { path = "../matw-tools" }

tokio = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }

ratatui = "0.28"
crossterm = "0.28"
ansi-to-tui = "6.0"
unicode-width = "0.2"
```

**Step 3: Create lib.rs**

```rust
pub mod app;
pub mod ui;
pub mod event;

pub use app::App;
pub use ui::UI;
pub use event::{Event, EventHandler};
```

**Step 4: Run cargo check**

Run: `cargo check -p matw-tui`
Expected: OK

**Step 5: Commit**

```bash
git add Cargo.toml crates/matw-tui/
git commit -m "feat: add matw-tui crate structure"
```

---

### Task 19: Implement Event Handling

**Files:**
- Create: `crates/matw-tui/src/event.rs`

**Step 1: Write event system**

```rust
use crossterm::event::{self, Event as CrosstermEvent, KeyEvent, KeyEventKind, MouseEvent};
use std::sync::mpsc;
use tokio::sync::mpsc as tokio_mpsc;

pub enum Event {
    Key(KeyEvent),
    Mouse(MouseEvent),
    Resize(u16, u16),
    Tick,
}

pub struct EventHandler {
    sender: tokio_mpsc::UnboundedSender<Event>,
    receiver: tokio_mpsc::UnboundedReceiver<Event>,
}

impl EventHandler {
    pub fn new(tick_rate_ms: u64) -> Self {
        let (sender, receiver) = tokio_mpsc::unbounded_channel();

        tokio::spawn(async move {
            let mut last_tick = std::time::Instant::now();
            let tick_duration = std::time::Duration::from_millis(tick_rate_ms);

            loop {
                let timeout = tick_duration
                    .checked_sub(last_tick.elapsed())
                    .unwrap_or(tick_duration);

                if event::poll(timeout).unwrap() {
                    if let CrosstermEvent::Key(key) = event::read().unwrap() {
                        if key.kind == KeyEventKind::Press {
                            sender.send(Event::Key(key)).unwrap();
                        }
                    }
                }

                if last_tick.elapsed() >= tick_duration {
                    sender.send(Event::Tick).unwrap();
                    last_tick = std::time::Instant::now();
                }
            }
        });

        Self { sender, receiver }
    }

    pub async fn next(&mut self) -> Option<Event> {
        self.receiver.recv().await
    }
}
```

**Step 2: Commit**

```bash
git add crates/matw-tui/src/event.rs
git commit -m "feat: add event handling for TUI"
```

---

### Task 20: Implement App State

**Files:**
- Create: `crates/matw-tui/src/app.rs`

**Step 1: Write app state**

```rust
use matw_core::{Message, Role, Session};
use matw_tools::Tool;
use std::sync::Arc;

pub struct App {
    pub session: Session,
    pub input: String,
    pub messages: Vec<Message>,
    pub should_quit: bool,
    pub tools: Vec<Arc<dyn Tool>>,
    pub status: String,
}

impl App {
    pub fn new(session: Session, tools: Vec<Arc<dyn Tool>>) -> Self {
        Self {
            session,
            input: String::new(),
            messages: Vec::new(),
            should_quit: false,
            tools,
            status: "Ready".to_string(),
        }
    }

    pub fn handle_input(&mut self, c: char) {
        self.input.push(c);
    }

    pub fn handle_backspace(&mut self) {
        self.input.pop();
    }

    pub fn submit_input(&mut self) {
        if self.input.is_empty() {
            return;
        }

        let msg = Message::new_user(self.input.clone());
        self.messages.push(msg);
        self.session.add_message(msg);
        self.input.clear();
        self.status = "Processing...".to_string();
    }

    pub fn quit(&mut self) {
        self.should_quit = true;
    }
}
```

**Step 2: Commit**

```bash
git add crates/matw-tui/src/app.rs
git commit -m "feat: add app state management"
```

---

### Task 21: Implement UI Layout

**Files:**
- Create: `crates/matw-tui/src/ui.rs`

**Step 1: Write UI renderer**

```rust
use ratatui::{
    backend::Backend,
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span, Text},
    widgets::{Block, Borders, Paragraph, Wrap},
    Frame, Terminal,
};
use matw_core::{Content, Message, Role};
use ansi_to_tui::ToText;

pub struct UI;

impl UI {
    pub fn draw<B: Backend>(f: &mut Frame<B>, app: &crate::App) {
        let chunks = Layout::default()
            .direction(Direction::Vertical)
            .margin(1)
            .constraints([
                Constraint::Min(0),   // Messages area
                Constraint::Length(3), // Input area
            ])
            .split(f.size());

        Self::draw_messages(f, app, chunks[0]);
        Self::draw_input(f, app, chunks[1]);
    }

    fn draw_messages<B: Backend>(f: &mut Frame<B>, app: &crate::App, area: Rect) {
        let mut lines = Vec::new();

        for msg in &app.messages {
            let (role_color, role_name) = match msg.role() {
                Role::User => (Color::Green, "User"),
                Role::Assistant => (Color::Blue, "Assistant"),
                Role::System => (Color::Yellow, "System"),
                Role::Tool => (Color::Cyan, "Tool"),
            };

            lines.push(Line::from(vec![
                Span::styled(
                    format!("[{}]", role_name),
                    Style::default().fg(role_color).add_modifier(Modifier::BOLD),
                ),
                Span::raw(" "),
            ]));

            // Handle content
            match msg.content() {
                Content::Text(text) => {
                    for line in text.lines() {
                        lines.push(Line::from(vec![
                            Span::raw("  "),
                            Span::raw(line),
                        ]));
                    }
                }
                Content::ToolUse { name, input, .. } => {
                    lines.push(Line::from(vec![
                        Span::raw("  "),
                        Span::styled(
                            format!("Using tool: {}", name),
                            Style::default().fg(Color::Cyan),
                        ),
                    ]));
                }
                Content::ToolResult { content, is_error, .. } => {
                    let color = if *is_error { Color::Red } else { Color::Gray };
                    for line in content.lines() {
                        lines.push(Line::from(vec![
                            Span::raw("  "),
                            Span::styled(line, Style::default().fg(color)),
                        ]));
                    }
                }
            }

            lines.push(Line::from(""));
        }

        let paragraph = Paragraph::new(lines)
            .block(Block::default()
                .borders(Borders::ALL)
                .title("Conversation")
            )
            .wrap(Wrap { trim: true });

        f.render_widget(paragraph, area);
    }

    fn draw_input<B: Backend>(f: &mut Frame<B>, app: &crate::App, area: Rect) {
        let input = Paragraph::new(app.input.as_str())
            .block(Block::default()
                .borders(Borders::ALL)
                .title(format!("Input | Status: {}", app.status))
            );

        f.render_widget(input, area);
    }
}
```

**Step 2: Commit**

```bash
git add crates/matw-tui/src/ui.rs
git commit -m "feat: add TUI layout with messages and input"
```

---

### Task 22: Create TUI Main Loop

**Files:**
- Create: `crates/matw-tui/src/main.rs`
- Modify: `crates/matw-tui/src/lib.rs`

**Step 1: Write main loop**

```rust
use crate::{App, EventHandler, Event, UI};
use crossterm::{
    event::{KeyCode, KeyEvent},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use matw_core::Session;
use matw_tools::all_tools;
use ratatui::{backend::CrosstermBackend, Terminal};
use std::{io, error::Error};

pub async fn run() -> Result<(), Box<dyn Error>> {
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let session = Session::new(std::env::current_dir()?);
    let tools: Vec<_> = all_tools().into_iter().map(|t| std::sync::Arc::from(t) as std::sync::Arc<dyn matw_tools::Tool>).collect();
    let mut app = App::new(session, tools);
    let mut events = EventHandler::new(250);

    loop {
        terminal.draw(|f| UI::draw(f, &app))?;

        if let Some(event) = events.next().await {
            match event {
                Event::Key(key) => {
                    if key.kind == crossterm::event::KeyEventKind::Press {
                        match key.code {
                            KeyCode::Char(c) => app.handle_input(c),
                            KeyCode::Backspace => app.handle_backspace(),
                            KeyCode::Enter => app.submit_input(),
                            KeyCode::Char('q') => app.quit(),
                            KeyCode::Esc => app.quit(),
                            _ => {}
                        }
                    }
                }
                Event::Tick => {}
                _ => {}
            }
        }

        if app.should_quit {
            break;
        }
    }

    disable_raw_mode()?;
    execute!(io::stdout(), LeaveAlternateScreen)?;
    Ok(())
}
```

**Step 2: Update matw-cli to use TUI**

```rust
// crates/matw-cli/src/main.rs
use matw_tui::run;

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    run().await?;
    Ok(())
}
```

**Step 3: Test TUI**

Run: `cargo run -p matw-cli`
Expected: Terminal UI with input area

**Step 4: Commit**

```bash
git add crates/matw-tui/src/main.rs crates/matw-tui/src/lib.rs crates/matw-cli/src/main.rs
git commit -m "feat: add TUI main loop"
```

---

## Phase 5: MCP Plugin System

### Task 23: Create matw-mcp Crate

**Files:**
- Create: `crates/matw-mcp/Cargo.toml`
- Create: `crates/matw-mcp/src/lib.rs`

**Step 1: Update workspace**

```toml
[workspace]
members = [
    "crates/matw-core",
    "crates/matw-ai",
    "crates/matw-tools",
    "crates/matw-tui",
    "crates/matw-mcp",
]
```

**Step 2: Create Cargo.toml**

```toml
[package]
name = "matw-mcp"
version = "0.1.0"
edition = "2021"

[dependencies]
matw-core = { path = "../matw-core" }
matw-tools = { path = "../matw-tools" }

tokio = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
thiserror = { workspace = true }

# JSON-RPC
async-trait = "0.1"
jsonrpsee = { version = "0.24", features = ["server", "client"] }
```

**Step 3: Commit**

```bash
git add Cargo.toml crates/matw-mcp/
git commit -m "feat: add matw-mcp crate structure"
```

---

### Task 24: Implement MCP Protocol

**Files:**
- Create: `crates/matw-mcp/src/protocol.rs`

**Step 1: Write MCP protocol types**

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonRpcRequest {
    pub jsonrpc: String,
    pub id: serde_json::Value,
    pub method: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub params: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonRpcResponse {
    pub jsonrpc: String,
    pub id: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<JsonRpcError>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonRpcError {
    pub code: i32,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<serde_json::Value>,
}

// MCP-specific types

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tool {
    pub name: String,
    pub description: String,
    pub input_schema: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCall {
    pub name: String,
    pub arguments: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolResult {
    pub content: Vec<ContentItem>,
    pub is_error: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ContentItem {
    #[serde(rename = "text")]
    Text { text: String },
    #[serde(rename = "image")]
    Image { data: String, mime_type: String },
    #[serde(rename = "resource")]
    Resource { uri: String },
}
```

**Step 2: Commit**

```bash
git add crates/matw-mcp/src/protocol.rs
git commit -m "feat: add MCP protocol types"
```

---

### Task 25: Implement MCP Server

**Files:**
- Create: `crates/matw-mcp/src/server.rs`

**Step 1: Write MCP server**

```rust
use super::protocol::*;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct MCPServer {
    tools: Arc<RwLock<HashMap<String, Box<dyn MCTool>>>>,
}

#[async_trait::async_trait]
pub trait MCTool: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn input_schema(&self) -> serde_json::Value;
    async fn execute(&self, args: serde_json::Value) -> Result<Vec<ContentItem>, String>;
}

impl MCPServer {
    pub fn new() -> Self {
        Self {
            tools: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn register_tool(&self, tool: Box<dyn MCTool>) {
        let mut tools = self.tools.write().await;
        tools.insert(tool.name().to_string(), tool);
    }

    pub async fn handle_request(&self, request: JsonRpcRequest) -> JsonRpcResponse {
        let result = match request.method.as_str() {
            "tools/list" => self.list_tools().await,
            "tools/call" => self.call_tool(request.params).await,
            _ => Err(JsonRpcError {
                code: -32601,
                message: "Method not found".to_string(),
                data: None,
            }),
        };

        match result {
            Ok(result) => JsonRpcResponse {
                jsonrpc: "2.0".to_string(),
                id: request.id,
                result: Some(result),
                error: None,
            },
            Err(error) => JsonRpcResponse {
                jsonrpc: "2.0".to_string(),
                id: request.id,
                result: None,
                error: Some(error),
            },
        }
    }

    async fn list_tools(&self) -> Result<serde_json::Value, JsonRpcError> {
        let tools = self.tools.read().await;
        let tool_list: Vec<Tool> = tools.values().map(|t| {
            Tool {
                name: t.name().to_string(),
                description: t.description().to_string(),
                input_schema: t.input_schema(),
            }
        }).collect();

        Ok(serde_json::json!({ "tools": tool_list }))
    }

    async fn call_tool(&self, params: Option<serde_json::Value>) -> Result<serde_json::Value, JsonRpcError> {
        let params = params.ok_or_else(|| JsonRpcError {
            code: -32602,
            message: "Invalid params".to_string(),
            data: None,
        })?;

        let call: ToolCall = serde_json::from_value(params).map_err(|_| JsonRpcError {
            code: -32602,
            message: "Invalid tool call".to_string(),
            data: None,
        })?;

        let tools = self.tools.read().await;
        let tool = tools.get(&call.name).ok_or_else(|| JsonRpcError {
            code: -32602,
            message: format!("Tool not found: {}", call.name),
            data: None,
        })?;

        let content = tool.execute(call.arguments).await.map_err(|e| JsonRpcError {
            code: -32603,
            message: e,
            data: None,
        })?;

        Ok(serde_json::to_value(ToolResult {
            content,
            is_error: false,
        }).unwrap())
    }
}
```

**Step 2: Commit**

```bash
git add crates/matw-mcp/src/server.rs
git commit -m "feat: add MCP server implementation"
```

---

### Task 26: Bridge matw-tools to MCP

**Files:**
- Create: `crates/matw-mcp/src/bridge.rs`

**Step 1: Write bridge adapter**

```rust
use super::server::{MCTool, MCPServer};
use super::protocol::ContentItem;
use matw_tools::Tool as MatwTool;
use std::sync::Arc;

pub struct ToolAdapter {
    tool: Arc<dyn MatwTool>,
}

impl ToolAdapter {
    pub fn new(tool: Arc<dyn MatwTool>) -> Self {
        Self { tool }
    }
}

#[async_trait::async_trait]
impl MCTool for ToolAdapter {
    fn name(&self) -> &str {
        self.tool.name()
    }

    fn description(&self) -> &str {
        self.tool.description()
    }

    fn input_schema(&self) -> serde_json::Value {
        self.tool.parameters_schema()
    }

    async fn execute(&self, args: serde_json::Value) -> Result<Vec<ContentItem>, String> {
        let output = self.tool.execute(args).await
            .map_err(|e| e.to_string())?;

        Ok(vec![ContentItem::Text {
            text: output.content,
        }])
    }
}

pub fn register_tools(server: &MCPServer, tools: Vec<Arc<dyn MatwTool>>) {
    for tool in tools {
        let adapter = Box::new(ToolAdapter::new(tool));
        tokio::spawn(async move {
            server.register_tool(adapter).await;
        });
    }
}
```

**Step 2: Commit**

```bash
git add crates/matw-mcp/src/bridge.rs
git commit -m "feat: add matw-tools to MCP bridge"
```

---

## Phase 6: Agent Orchestration

### Task 27: Create matw-agent Crate

**Files:**
- Create: `crates/matw-agent/Cargo.toml`
- Create: `crates/matw-agent/src/lib.rs`

**Step 1: Update workspace**

```toml
[workspace]
members = [
    "crates/matw-core",
    "crates/matw-ai",
    "crates/matw-tools",
    "crates/matw-tui",
    "crates/matw-mcp",
    "crates/matw-agent",
]
```

**Step 2: Create Cargo.toml**

```toml
[package]
name = "matw-agent"
version = "0.1.0"
edition = "2021"

[dependencies]
matw-core = { path = "../matw-core" }
matw-ai = { path = "../matw-ai" }
matw-tools = { path = "../matw-tools" }

tokio = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
thiserror = { workspace = true }
async-trait = "0.1"
```

**Step 3: Commit**

```bash
git add Cargo.toml crates/matw-agent/
git commit -m "feat: add matw-agent crate structure"
```

---

### Task 28: Implement Agent Loop

**Files:**
- Create: `crates/matw-agent/src/agent.rs`

**Step 1: Write agent orchestration**

```rust
use matw_core::{Content, Message, Role, Session};
use matw_ai::{AIProvider, CompletionRequest, CompletionResponse, ToolDefinition};
use matw_tools::Tool;
use std::sync::Arc;

pub struct Agent<P: AIProvider> {
    provider: P,
    tools: Vec<Arc<dyn Tool>>,
    max_iterations: usize,
}

impl<P: AIProvider> Agent<P> {
    pub fn new(provider: P, tools: Vec<Arc<dyn Tool>>) -> Self {
        Self {
            provider,
            tools,
            max_iterations: 10,
        }
    }

    pub async fn process(&self, session: &mut Session) -> Result<(), AgentError> {
        let mut iteration = 0;

        loop {
            // Check max iterations
            if iteration >= self.max_iterations {
                return Err(AgentError::MaxIterationsReached);
            }

            // Get last user message
            let last_user_msg = session.messages()
                .iter()
                .rev()
                .find(|m| m.role() == Role::User)
                .ok_or(AgentError::NoUserMessage)?;

            // Prepare completion request
            let tool_defs: Vec<_> = self.tools.iter()
                .map(|t| ToolDefinition {
                    name: t.name().to_string(),
                    description: t.description().to_string(),
                    parameters: t.parameters_schema(),
                })
                .collect();

            let request = CompletionRequest {
                messages: session.messages().to_vec(),
                tools: tool_defs,
                model: "default".to_string(),
                max_tokens: Some(4096),
                temperature: Some(0.7),
                system_prompt: Some(self.get_system_prompt()),
            };

            // Get AI response
            let response = self.provider.complete(request).await
                .map_err(|e| AgentError::AIProvider(e.to_string()))?;

            // Add assistant message
            session.add_message(Message::new_assistant(response.content.clone()));

            // Check for tool uses
            if !response.tool_uses.is_empty() {
                for tool_use in response.tool_uses {
                    // Add tool use message
                    session.add_message(Message::new_tool_use(
                        tool_use.id.clone(),
                        tool_use.name.clone(),
                        tool_use.input,
                    ));

                    // Execute tool
                    let tool = self.tools.iter()
                        .find(|t| t.name() == tool_use.name)
                        .ok_or(AgentError::ToolNotFound(tool_use.name.clone()))?;

                    let output = tool.execute(tool_use.input).await
                        .map_err(|e| AgentError::ToolExecution(e.to_string()))?;

                    // Add tool result message
                    session.add_message(Message::new_tool_result(
                        tool_use.id,
                        output.content,
                        output.is_error,
                    ));
                }

                iteration += 1;
                continue;
            }

            // No more tool uses, done
            break;
        }

        Ok(())
    }

    fn get_system_prompt(&self) -> String {
        format!("You are a helpful AI coding assistant with access to tools.")
    }
}

#[derive(Debug, thiserror::Error)]
pub enum AgentError {
    #[error("Max iterations reached")]
    MaxIterationsReached,

    #[error("No user message found")]
    NoUserMessage,

    #[error("AI provider error: {0}")]
    AIProvider(String),

    #[error("Tool not found: {0}")]
    ToolNotFound(String),

    #[error("Tool execution error: {0}")]
    ToolExecution(String),
}
```

**Step 2: Commit**

```bash
git add crates/matw-agent/src/agent.rs
git commit -m "feat: add agent orchestration loop"
```

---

### Task 29: Integrate Agent with TUI

**Files:**
- Modify: `crates/matw-tui/src/app.rs`
- Modify: `crates/matw-tui/src/main.rs`

**Step 1: Add agent to app**

```rust
// crates/matw-tui/src/app.rs
use matw_agent::Agent;

pub struct App<P: matw_ai::AIProvider> {
    pub session: Session,
    pub input: String,
    pub messages: Vec<Message>,
    pub should_quit: bool,
    pub tools: Vec<Arc<dyn Tool>>,
    pub status: String,
    pub agent: Option<Agent<P>>,
}

impl<P: matw_ai::AIProvider> App<P> {
    pub fn with_agent(mut self, agent: Agent<P>) -> Self {
        self.agent = Some(agent);
        self
    }

    pub async fn submit_input(&mut self) {
        if self.input.is_empty() {
            return;
        }

        let msg = Message::new_user(self.input.clone());
        self.messages.push(msg.clone());
        self.session.add_message(msg);
        self.input.clear();
        self.status = "Processing...".to_string();

        // Run agent if available
        if let Some(ref agent) = self.agent {
            if let Err(e) = agent.process(&mut self.session).await {
                self.status = format!("Error: {}", e);
                self.messages.push(Message::new_assistant(format!("Error: {}", e)));
            } else {
                self.status = "Ready".to_string();
                // Update messages from session
                self.messages = self.session.messages().to_vec();
            }
        }
    }
}
```

**Step 2: Update main.rs**

```rust
// crates/matw-tui/src/main.rs
use matw_ai::providers::ClaudeProvider;
use matw_agent::Agent;
use matw_tools::all_tools;

pub async fn run(api_key: String) -> Result<(), Box<dyn Error>> {
    // ... setup terminal ...

    let session = Session::new(std::env::current_dir()?);
    let tools: Vec<_> = all_tools().into_iter()
        .map(|t| std::sync::Arc::from(t) as std::sync::Arc<dyn matw_tools::Tool>)
        .collect();

    let provider = ClaudeProvider::new(api_key, None);
    let agent = Agent::new(provider, tools.clone());

    let mut app = App::new(session.clone(), tools)
        .with_agent(agent);

    // ... event loop ...
}
```

**Step 3: Commit**

```bash
git add crates/matw-tui/src/app.rs crates/matw-tui/src/main.rs
git commit -m "feat: integrate agent with TUI"
```

---

### Task 30: Add Streaming Support

**Files:**
- Create: `crates/matw-agent/src/streaming.rs`

**Step 1: Implement streaming agent**

```rust
use futures::StreamExt;
use matw_ai::{AIProvider, Chunk, ChunkStream, CompletionRequest};
use matw_core::{Content, Message, Role, Session};

pub async fn process_streaming<P: AIProvider>(
    provider: &P,
    session: &mut Session,
    on_delta: impl Fn(String),
) -> Result<(), AgentError> {
    let request = CompletionRequest {
        messages: session.messages().to_vec(),
        tools: vec![],
        model: "default".to_string(),
        max_tokens: Some(4096),
        temperature: Some(0.7),
        system_prompt: None,
    };

    let stream = provider.stream_completion(request).await
        .map_err(|e| AgentError::AIProvider(e.to_string()))?;

    let mut response_text = String::new();

    futures::pin_mut!(stream);

    while let Some(chunk_result) = stream.next().await {
        let chunk = chunk_result.map_err(|e| AgentError::AIProvider(e.to_string()))?;

        match chunk {
            Chunk::Delta(text) => {
                on_delta(text.clone());
                response_text.push_str(&text);
            }
            Chunk::Done => break,
            _ => {}
        }
    }

    // Add final message
    session.add_message(Message::new_assistant(response_text));

    Ok(())
}
```

**Step 2: Commit**

```bash
git add crates/matw-agent/src/streaming.rs
git commit -m "feat: add streaming response support"
```

---

## Summary

Phase 4-6 adds:

1. **Phase 4**: Full ratatui TUI with event handling, app state, and terminal UI
2. **Phase 5**: MCP plugin system with JSON-RPC protocol and tool bridging
3. **Phase 6**: Agent orchestration with tool execution and streaming responses

**Total tasks**: 13 (Task 18-30)
**Estimated completion time**: 2-3 weeks

Integration points:
- TUI uses Agent for processing
- Agent uses AIProvider for responses
- MCP bridges matw-tools to external plugins
- All layers use matw-core types
